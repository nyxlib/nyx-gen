# -*- coding: utf-8 -*-
########################################################################################################################

import os

########################################################################################################################

from .posix_c import PosixCGenerator

from ..abstract_generator import generator_config

########################################################################################################################

@generator_config(name = 'gnuradio', null = 'NULL', src_ext = 'c', head_ext = 'h')
class GNURadioGenerator(PosixCGenerator):

    ####################################################################################################################

    def create_directories(self) -> None:

        super().create_directories()

        os.makedirs(os.path.join(self._driver_path, 'grc'), exist_ok = True)

    ####################################################################################################################

    def generate(self) -> None:

        self._generate_cmake()
        self._generate_header()
        self._generate_main()
        self._generate_glue()
        self._generate_devices()
        self._generate_python_pkg_and_grc()

    ####################################################################################################################

    def _generate_header(self) -> None:

        template = '''
/* !!! AUTOGENERATED FILE !!! */
/*--------------------------------------------------------------------------------------------------------------------*/

#ifndef INDI_NODE_{{ descr.nodeName|upper }}_H
#define INDI_NODE_{{ descr.nodeName|upper }}_H

/*--------------------------------------------------------------------------------------------------------------------*/

#include <Python.h>
#include <pthread.h>
#include <nyx_node.h>

/*--------------------------------------------------------------------------------------------------------------------*/
{%  for d in devices -%}
{%-   for v in d.vectors -%}
{%-     for df in v.defs %}
extern nyx_dict_t *vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }};
{%-     endfor %}
extern nyx_dict_t *vector_{{ d.name|lower }}_{{ v.name|lower }};
{%    endfor -%}
{%- endfor %}

/*--------------------------------------------------------------------------------------------------------------------*/
{%  for d in devices -%}
{%-   for v in d.vectors -%}
{%-     for df in v.defs if df.callback %}
extern PyObject *vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback;
{%-     endfor -%}
{%-   endfor -%}
{%- endfor %}

/*--------------------------------------------------------------------------------------------------------------------*/
{%  for d in devices %}
void device_{{ d.name|lower }}_initialize();
{%- endfor %}
{%  for d in devices %}
void device_{{ d.name|lower }}_finalize();
{%- endfor %}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_glue_initialize();

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_device_initialize(nyx_node_t *node);

void nyx_device_finalize(nyx_node_t *node);

/*--------------------------------------------------------------------------------------------------------------------*/

#endif /* INDI_NODE_{{ descr.nodeName|upper }}_H */

/*--------------------------------------------------------------------------------------------------------------------*/
'''[1:]

        filename = os.path.join(self._driver_path, 'src', 'autogen', f'glue.{self._head_ext}')

        with open(filename, 'wt', encoding = 'utf-8') as f:

            f.write(self.render(
                template,
                devices = self._devices
            ))

    ####################################################################################################################

    def _generate_cmake(self) -> None:

        template = '''
########################################################################################################################

cmake_minimum_required(VERSION 3.5)

########################################################################################################################

project({{ descr.nodeName|lower }} C)

set(CMAKE_C_STANDARD 99)

set(Python3_EXECUTABLE /usr/bin/python3)

add_compile_options(-DPY_SSIZE_T_CLEAN -Wall -Wno-unknown-pragmas -Wno-unused-function -O3)

########################################################################################################################

find_package(Threads REQUIRED)
find_package(Python3 REQUIRED COMPONENTS Interpreter Development)
find_package(NyxNode REQUIRED)

########################################################################################################################

set(SOURCE_FILES
    {{ cmake_files|join('\\n    ') }}
    ./src/autogen/glue.{{ src_ext }}
    ./src/main.{{ src_ext }}
)

########################################################################################################################

add_library({{ descr.nodeName|lower }} SHARED ${SOURCE_FILES})
set_target_properties({{ descr.nodeName|lower }} PROPERTIES PREFIX "")

target_include_directories({{ descr.nodeName|lower }} PRIVATE ${Python3_INCLUDE_DIRS} ${NYXNODE_INCLUDE_DIR})

target_link_libraries({{ descr.nodeName|lower }} PRIVATE Threads::Threads ${Python3_LIBRARIES} NyxNode::nyx-node-{{ 'static' if descr.static else 'shared' }})

########################################################################################################################

include(GNUInstallDirs)

install(TARGETS {{ descr.nodeName|lower }} LIBRARY DESTINATION ${Python3_SITEARCH})

install(FILES ./src/__init__.py DESTINATION ${Python3_SITEARCH}/gnuradio/nyx_{{ descr.nodeName|lower }}/)

install(FILES ./grc/nyx_{{ descr.nodeName|lower }}.block.yml DESTINATION ${CMAKE_INSTALL_DATADIR}/gnuradio/grc/blocks/)
install(FILES ./grc/nyx_{{ descr.nodeName|lower }}_sink.block.yml DESTINATION ${CMAKE_INSTALL_DATADIR}/gnuradio/grc/blocks/)

########################################################################################################################
'''[1:]

        filename = os.path.join(self._driver_path, 'CMakeLists.txt')

        if self._override_cmake or not os.path.isfile(filename):

            with open(filename, 'wt', encoding = 'utf-8') as f:

                f.write(self.render(
                    template,
                    cmake_files = [os.path.join('.', 'src', f'device_{device["name"].lower()}.{self._src_ext}') for device in self._devices]
                ))

    ####################################################################################################################

    def _generate_main(self) -> None:

        template = '''
#define MQTT_USERNAME {% if descr.enableMQTT %}"{{ descr.mqttUsername }}"{% else %}{{ null }}{% endif %}
#define MQTT_PASSWORD {% if descr.enableMQTT %}"{{ descr.mqttPassword }}"{% else %}{{ null }}{% endif %}
'''[1:]

        filename = os.path.join(self._driver_path, 'src', f'credentials.{self._head_ext}')

        with open(filename, 'wt', encoding='utf-8') as f:

            f.write(self.render(template))

        template = r'''
/*--------------------------------------------------------------------------------------------------------------------*/

#include <string.h>

#include "autogen/glue.{{ head_ext }}"
#include "credentials.{{ head_ext }}"

__NYX_NULLABLE__ str_t nyx_string_dup(
    __NYX_NULLABLE__ STR_t s
);

/*--------------------------------------------------------------------------------------------------------------------*/

static char indi_url[1024];
static char mqtt_url[1024];
static char nss_url[1024];
static char mqtt_username[1024];
static char mqtt_password[1024];

/*--------------------------------------------------------------------------------------------------------------------*/

static nyx_node_t *node = NULL;

/*--------------------------------------------------------------------------------------------------------------------*/

static pthread_t worker_thread = 0;

/*--*/ volatile bool worker_alive = false;

/*--------------------------------------------------------------------------------------------------------------------*/

static void *worker_routine(void *arg)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_set_log_level(NYX_LOG_LEVEL_INFO);

    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_memory_initialize();

    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_glue_initialize();

    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_dict_t *vector_list[] = {
{%- for d in devices -%}
{%-   for v in d.vectors %}
        vector_{{ d.name|lower }}_{{ v.name|lower }},
{%-   endfor -%}
{%- endfor %}
        {{ null }},
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    node = nyx_node_initialize(
        "{{ descr.nodeName }}",
        vector_list,
        indi_url,
        mqtt_url,
        nss_url,
        mqtt_username,
        mqtt_password,
        {{ null }},
        3000,
        true
    );

    nyx_device_initialize(node);
    for(worker_alive = true; worker_alive;) nyx_node_poll(node, {{ descr.nodeTimeout }});
    nyx_device_finalize(node);

    nyx_node_finalize(node, true);

    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_memory_finalize();

    /*----------------------------------------------------------------------------------------------------------------*/

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------*/

static PyObject *worker_start(PyObject *self, PyObject *args)
{
    if(worker_thread == 0)
    {
        /*------------------------------------------------------------------------------------------------------------*/

        STR_t py_indi_url      = NULL;
        STR_t py_mqtt_url      = NULL;
        STR_t py_nss_url       = NULL;
        STR_t py_mqtt_username = NULL;
        STR_t py_mqtt_password = NULL;

        if(!PyArg_ParseTuple(args, "|zzzzz",
            &py_indi_url,
            &py_mqtt_url,
            &py_nss_url,
            &py_mqtt_username,
            &py_mqtt_password
        )) {
            return NULL;
        }

        strcpy(indi_url,      py_indi_url      ? py_indi_url      : "");
        strcpy(mqtt_url,      py_mqtt_url      ? py_mqtt_url      : "");
        strcpy(nss_url,       py_nss_url       ? py_nss_url       : "");
        strcpy(mqtt_username, py_mqtt_username ? py_mqtt_username : "");
        strcpy(mqtt_password, py_mqtt_password ? py_mqtt_password : "");

        /*------------------------------------------------------------------------------------------------------------*/

        if(pthread_create(&worker_thread, NULL, worker_routine, NULL) != 0x00)
        {
            PyErr_SetString(PyExc_RuntimeError, "Failed to start Nyx worker thread");

            worker_alive = false;

            return NULL;
        }
        else
        {
            worker_alive = true;

            Py_RETURN_NONE;
        }

        /*------------------------------------------------------------------------------------------------------------*/
    }

    Py_RETURN_NONE;
}

/*--------------------------------------------------------------------------------------------------------------------*/

static PyObject *worker_stop(PyObject *self, PyObject *noargs)
{
    if(worker_thread != 0)
    {
        worker_alive = false;

        if(pthread_join(worker_thread, NULL) != 0x00)
        {
            PyErr_SetString(PyExc_RuntimeError, "Failed to stop Nyx worker thread");

            worker_thread = 0;

            return NULL;
        }
        else
        {
            worker_thread = 0;

            Py_RETURN_NONE;
        }
    }

    Py_RETURN_NONE;
}

/*--------------------------------------------------------------------------------------------------------------------*/

static PyObject *send_message(PyObject *self, PyObject *args)
{
    if(node != NULL)
    {
        STR_t device;
        STR_t message;

        if(!PyArg_ParseTuple(args, "ss", &device, &message))
        {
            return NULL;
        }

        nyx_node_send_message(node, device, message);
    }

    Py_RETURN_NONE;
}

/*--------------------------------------------------------------------------------------------------------------------*/

static PyObject *send_del_property(PyObject *self, PyObject *args)
{
    if(node != NULL)
    {
        STR_t device;
        STR_t name;
        STR_t message;

        if(!PyArg_ParseTuple(args, "szs", &device, &name, &message))
        {
            return NULL;
        }
        
        nyx_node_send_del_property(node, device, name, message);
    }

    Py_RETURN_NONE;
}

/*--------------------------------------------------------------------------------------------------------------------*/

static PyObject *stream_pub(PyObject *self, PyObject *args)
{
    if(node != NULL)
    {
        /*------------------------------------------------------------------------------------------------------------*/

        STR_t device_name;
        STR_t stream_name;
        Py_ssize_t max_len;
        PyObject *field_dict;

        if(!PyArg_ParseTuple(args, "ssnO!", &device_name, &stream_name, &max_len, &PyDict_Type, &field_dict))
        {
            return NULL;
        }

        /*------------------------------------------------------------------------------------------------------------*/

        Py_ssize_t n_fields = PyDict_Size(field_dict);

        uint32_t hashes[n_fields];
        size_t sizes[n_fields];
        BUFF_t buffs[n_fields];

        /*------------------------------------------------------------------------------------------------------------*/

        Py_ssize_t name_len;
        STR_t      name_buf;
            
        PyObject *keys = PyDict_Keys(field_dict);

        for(Py_ssize_t i = 0; i < n_fields; i++)
        {
            PyObject *key = PyList_GetItem(keys, i);
            PyObject *val = PyDict_GetItem(field_dict, key);

            if(!PyUnicode_Check(key) || !PyBytes_Check(val))
            {
                PyErr_SetString(PyExc_TypeError, "Each field must be {name: bytes}");
                return NULL;
            }

            name_buf = PyUnicode_AsUTF8AndSize(key, &name_len);

            hashes[i] = nyx_hash(name_len, name_buf, 0x5358594EU);
            sizes[i] = (size_t) PyBytes_Size(val);
            buffs[i] = (buff_t) PyBytes_AsString(val);
        }

        /*------------------------------------------------------------------------------------------------------------*/

        nyx_nss_pub(node, device_name, stream_name, (size_t) n_fields, hashes, sizes, buffs);
	
        /*------------------------------------------------------------------------------------------------------------*/

        Py_RETURN_NONE;

        /*------------------------------------------------------------------------------------------------------------*/
    }

    Py_RETURN_NONE;
}

{#--------------------------------------------------------------------------------------------------------------------#}
{%- set py_methods = [] -%}
{#--------------------------------------------------------------------------------------------------------------------#}
{%- for d in devices -%}
{%-   for v in d.vectors -%}
{%-     for df in v.defs -%}
{#--------------------------------------------------------------------------------------------------------------------#}
{%-       set ctype = '' -%}
{%-       set suffix = '' -%}
{%-       set pfmt  = '' -%}
{%-       if v.type == 'number' -%}
{%-         set subtype = get_number_type(df.format) -%}
{%-         if   subtype == NYX_NUMBER_INT    -%}{%- set ctype = 'int'           -%}{%- set suffix = 'int' %}{%- set pfmt = 'i' -%}
{%-         elif subtype == NYX_NUMBER_UINT   -%}{%- set ctype = 'unsigned int'  -%}{%- set suffix = 'uint' %}{%- set pfmt = 'i' -%}
{%-         elif subtype == NYX_NUMBER_LONG   -%}{%- set ctype = 'long'          -%}{%- set suffix = 'long' %}{%- set pfmt = 'l' -%}
{%-         elif subtype == NYX_NUMBER_ULONG  -%}{%- set ctype = 'unsigned long' -%}{%- set suffix = 'ulong' %}{%- set pfmt = 'l' -%}
{%-         elif subtype == NYX_NUMBER_DOUBLE -%}{%- set ctype = 'double'        -%}{%- set suffix = 'double' %}{%- set pfmt = 'd' -%}
{%-         endif -%}
{%-       elif v.type == 'text'   -%}{%- set ctype = 'STR_t' -%}{%- set suffix = '' -%}{%- set pfmt = 's' -%}
{%-       elif v.type == 'switch' -%}{%- set ctype = 'int'   -%}{%- set suffix = '' -%}{%- set pfmt = 'i' -%}
{%-       elif v.type == 'light'  -%}{%- set ctype = 'int'   -%}{%- set suffix = '' -%}{%- set pfmt = 'i' -%}
{%-       endif -%}
{#--------------------------------------------------------------------------------------------------------------------#}
{%-       if ctype -%}
{#--------------------------------------------------------------------------------------------------------------------#}
{%-         if df.callback -%}
/*--------------------------------------------------------------------------------------------------------------------*/

PyObject *vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback = NULL;

static PyObject *_register_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_callback(PyObject *self, PyObject *args)
{
    Py_XDECREF(vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback);

    if(!PyArg_ParseTuple(args, "O", &vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback))
    {
        return NULL;
    }

    if(!PyCallable_Check(vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback))
    {        
        vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback = NULL;
     
        PyErr_SetString(PyExc_TypeError, "Parameter must be callable");

        return NULL;
    }

    Py_XINCREF(vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback);

    Py_RETURN_NONE;
}

{# -------------------------------------------------------------------------------------------------------------------#}
{%-           set _ = py_methods.append('{"register_' ~ d.name|lower ~ '_' ~ v.name|lower ~ '_' ~ df.name|lower ~ '_callback", _register_' ~ d.name|lower ~ '_' ~ v.name|lower ~ '_' ~ df.name|lower ~ '_callback, METH_VARARGS, "Registers the callback for ' ~ d.name ~ '::' ~ v.name ~ '::' ~ df.name ~ '"},') -%}
{#--------------------------------------------------------------------------------------------------------------------#}
{%-         endif -%}
{#--------------------------------------------------------------------------------------------------------------------#}
static PyObject *_set_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_value(PyObject *self, PyObject *args)
{
    if(worker_alive)
    {
        {{ ctype }} value;

        if(!PyArg_ParseTuple(args, "{{ pfmt }}", &value))
        {
            return NULL;
        }
{%          if v.type == 'number' %}
        nyx_number_prop_set_{{ suffix }}((nyx_dict_t *) vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}, value);
{%-         elif v.type == 'text' %}
        nyx_text_prop_set((nyx_dict_t *) vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}, value);
{%-         elif v.type == 'switch' %}
        nyx_switch_prop_set((nyx_dict_t *) vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}, value);
{%-         elif v.type == 'light' %}
        nyx_light_prop_set((nyx_dict_t *) vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}, value);
{%-         endif %}
    }

    Py_RETURN_NONE;
}

{# -------------------------------------------------------------------------------------------------------------------#}
{%          set _ = py_methods.append('{"set_' ~ d.name|lower ~ '_' ~ v.name|lower ~ '_' ~ df.name|lower ~ '_value", _set_' ~ d.name|lower ~ '_' ~ v.name|lower ~ '_' ~ df.name|lower ~ '_value, METH_VARARGS, "Sets the value for ' ~ d.name ~ '::' ~ v.name ~ '::' ~ df.name ~ '"},') -%}
{#--------------------------------------------------------------------------------------------------------------------#}
{%-       endif -%}
{#--------------------------------------------------------------------------------------------------------------------#}
{%-     endfor -%}
{%-   endfor -%}
{%- endfor %}
/*--------------------------------------------------------------------------------------------------------------------*/

static PyMethodDef MethodDefs[] = {
{%-  for m in py_methods %}
    {{ m }}
{%-  endfor -%}
    {"send_message", send_message, METH_VARARGS, "Sends a human-oriented message to the clients."},
    {"send_del_property", send_del_property, METH_VARARGS, "Sends a del-property message to the clients."},
    {"stream_pub", stream_pub, METH_VARARGS, "Publishes an entry to a stream."},
    {"start", worker_start, METH_VARARGS, "Starts the node."},
    {"stop", worker_stop, METH_NOARGS, "Stops the node."},
    {NULL, NULL, 0, NULL},
};

/*--------------------------------------------------------------------------------------------------------------------*/

static void ModuleFree(void *module)
{
    worker_stop(NULL, NULL);
}

/*--------------------------------------------------------------------------------------------------------------------*/

static struct PyModuleDef ModuleDef = {
    PyModuleDef_HEAD_INIT,
    "{{ descr.nodeName }}",
    NULL,
    -1,
    MethodDefs,
    NULL,
    NULL,
    NULL,
    ModuleFree
};

/*--------------------------------------------------------------------------------------------------------------------*/

PyMODINIT_FUNC PyInit_{{ descr.nodeName }}()
{
    PyObject *module = PyModule_Create(&ModuleDef);

    if(module != NULL)
    {
        PyModule_AddIntConstant(module, "NYX_STATE_IDLE", NYX_STATE_IDLE);
        PyModule_AddIntConstant(module, "NYX_STATE_OK", NYX_STATE_OK);
        PyModule_AddIntConstant(module, "NYX_STATE_BUSY", NYX_STATE_BUSY);
        PyModule_AddIntConstant(module, "NYX_STATE_ALERT", NYX_STATE_ALERT);

        PyModule_AddIntConstant(module, "NYX_ONOFF_ON", NYX_ONOFF_ON);
        PyModule_AddIntConstant(module, "NYX_ONOFF_OFF", NYX_ONOFF_OFF);
    }

    return module;
}

/*--------------------------------------------------------------------------------------------------------------------*/
'''[1:]

        filename = os.path.join(self._driver_path, 'src', f'main.{self._src_ext}')

        if self._override_main or not os.path.isfile(filename):

            with open(filename, 'wt', encoding = 'utf-8') as f:

                f.write(self.render(
                    template,
                    devices = self._devices
                ))

    ####################################################################################################################

    def _generate_devices(self) -> None:

        template = '''
/*--------------------------------------------------------------------------------------------------------------------*/

#include "autogen/glue.{{ head_ext }}"

/*--------------------------------------------------------------------------------------------------------------------*/

{%- set ns = namespace(any_callbacks = false) -%}
{#--------------------------------------------------------------------------------------------------------------------#}
{%- for v in device.vectors -%}
{%-   for df in v.defs if df.callback -%}
{%-     set ns.any_callbacks = true -%}
{%-     if v.type == 'number' -%}
{%-       set subtype = get_number_type(df.format) -%}
{%-       if   subtype == NYX_NUMBER_INT    -%}{% set ctype = 'int'           %}{% set pfmt = '(i)' %}
{%-       elif subtype == NYX_NUMBER_UINT   -%}{% set ctype = 'unsigned int'  %}{% set pfmt = '(i)' %}
{%-       elif subtype == NYX_NUMBER_LONG   -%}{% set ctype = 'long'          %}{% set pfmt = '(l)' %}
{%-       elif subtype == NYX_NUMBER_ULONG  -%}{% set ctype = 'unsigned long' %}{% set pfmt = '(l)' %}
{%-       elif subtype == NYX_NUMBER_DOUBLE -%}{% set ctype = 'double'        %}{% set pfmt = '(d)' %}
{%-       endif -%}
{%-     elif v.type in ['light','switch']   -%}{% set ctype = 'int'   %}{% set pfmt = '(i)' %}
{%-     elif v.type == 'text'               -%}{% set ctype = 'STR_t' %}{% set pfmt = '(s)' %}
{%-     elif v.type == 'blob'               -%}{% set ctype = None    %}{% set pfmt = '(O)' %}
{%-     endif -%}
{#------------------------------------------------------------------------------------------------------------------- #}
{%      if v.type == 'blob' -%}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def_vector, size_t size, BUFF_t buff)
{
    if(vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback != NULL)
{%-     else -%}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def_vector, {{ ctype }} new_value, {{ ctype }} old_value)
{
{%-       if v.type != 'text' %}
    if(new_value != old_value && vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback != NULL)
{%-       else %}
    if((strcmp(new_value, old_value) != 0 && vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback != NULL)
{%-       endif %}
{%-     endif %}
    {
        /*------------------------------------------------------------------------------------------------------------*/
        /* !!! AUTOGENERATED CODE !!!                                                                                 */
        /*------------------------------------------------------------------------------------------------------------*/

        PyGILState_STATE gstate = PyGILState_Ensure();
{%     if v.type == 'blob' %}
        PyObject *py_bytes = PyBytes_FromStringAndSize((const char *) buff, (Py_ssize_t) size);
        PyObject *args = Py_BuildValue("{{ pfmt }}", py_bytes);
        Py_DECREF(py_bytes);
{%-     else %}
        PyObject *args = Py_BuildValue("{{ pfmt }}", new_value);
{%-     endif %}
        
        PyObject *result = PyObject_CallObject(vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}_python_callback, args);
        
        Py_DECREF(args);
        
        if(result == NULL) {
            PyErr_Print();
        } else {
            Py_DECREF(result);
        }

        PyGILState_Release(gstate);
        
        /*------------------------------------------------------------------------------------------------------------*/
        /* USER FREE CODE                                                                                             */
        /*------------------------------------------------------------------------------------------------------------*/

        /* TO BE IMPLEMENTED */

        /*------------------------------------------------------------------------------------------------------------*/
    }

    return true;
}

/*--------------------------------------------------------------------------------------------------------------------*/

{%   endfor -%}
{%-   if v.callback and v.type != 'stream' %}
static void _{{ v.name|lower }}_callback(nyx_dict_t *vector, bool modified)
{
}
{%-   endif -%}
{%- endfor -%}

{%- if not ns.any_callbacks %}
/* TO BE IMPLEMENTED */
{%- endif %}

/*--------------------------------------------------------------------------------------------------------------------*/

void device_{{ device.name|lower }}_initialize(nyx_node_t *node)
{
{%- for v in device.vectors -%}
{%-   for df in v.defs if df.callback -%}
{%-     if v.type == 'number' -%}
{%          set subtype = get_number_type(df.format) -%}
{%-         if   subtype == NYX_NUMBER_INT   %}    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._int    = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         elif subtype == NYX_NUMBER_UINT  %}    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._uint   = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         elif subtype == NYX_NUMBER_LONG  %}    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._long   = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         elif subtype == NYX_NUMBER_ULONG %}    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._ulong  = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         elif subtype == NYX_NUMBER_DOUBLE %}   vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._double = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         endif -%}
{%-     elif v.type == 'text'   %}    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._str   = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-     elif v.type == 'light'  %}    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._int   = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-     elif v.type == 'switch' %}    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._int   = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-     elif v.type == 'blob'   %}    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._blob  = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-     endif -%}
{%    endfor -%}
{%-   if v.callback and v.type != 'stream' %}

    vector_{{ device.name|lower }}_{{ v.name|lower }}->base.in_callback._vector = _{{ v.name|lower }}_callback;
{%    endif -%}
{%- endfor %}

    /* TO BE IMPLEMENTED */
}

/*--------------------------------------------------------------------------------------------------------------------*/

void device_{{ device.name|lower }}_finalize(nyx_node_t *node)
{
    /* TO BE IMPLEMENTED */
}

/*--------------------------------------------------------------------------------------------------------------------*/
'''[1:]

        for device in self._devices:

            filename = os.path.join(self._driver_path, 'src', f'device_{device["name"].lower()}.{self._src_ext}')

            if self._override_device or not os.path.isfile(filename):

                with open(filename, 'wt', encoding = 'utf-8') as f:

                    f.write(self.render(
                        template,
                        device = device
                    ))

    ####################################################################################################################

    def _generate_python_pkg_and_grc(self) -> None:

        template_init = '''
########################################################################################################################

import atexit
import {{ descr.nodeName }} as _mod

import numpy as np
from gnuradio import gr

########################################################################################################################

def start(indi_url = "", mqtt_url = "", nss_url = "", mqtt_username = "", mqtt_password = ""):

    atexit.register(lambda: _mod.stop())

    _mod.start(indi_url, mqtt_url, nss_url, mqtt_username, mqtt_password)

########################################################################################################################

def stop():

    _mod.stop()

########################################################################################################################

def send_message(device, message):

    _mod.send_message(device, message)

########################################################################################################################

def stream_pub(device_name, stream_name, max_len, fields: dict[str, bytes]):

    _mod.stream_pub(device_name, stream_name, max_len, fields)

########################################################################################################################

class nyx_sink(gr.sync_block):

    def __init__(self, device_name = "", stream_name = "spectrum", samp_rate = 2.0e6, frequency = 100e6, fft_size = 8192):

        gr.sync_block.__init__(self, name = "Nyx Sink", in_sig = [(np.float32, fft_size)], out_sig = None)

        self.device_name  = device_name
        self.stream_name  = stream_name

        self.samp_rate = float(samp_rate)
        self.frequency = float(frequency)
        self.fft_size  = int(fft_size)

    def work(self, input_items, output_items):

        samp_rate = np.float32(self.samp_rate).tobytes()
        frequency = np.float32(self.frequency).tobytes()

        for msg in input_items[0]:

            samples = np.round(msg, decimals = 1).tobytes()

            data = {
                "samp_rate": samp_rate,
                "frequency": frequency,
                "samples": samples,
            }

            _mod.stream_pub(self.device_name, self.stream_name, 100, data)

        self.consume(0, len(input_items[0]))

        return 0

########################################################################################################################
'''[1:]

        filename = os.path.join(self._driver_path, 'src', '__init__.py')

        with open(filename, 'wt', encoding = 'utf-8') as f:

            f.write(self.render(template_init))

        parameter_list = []
        callback_regs  = []

        for d in self._devices:
            for v in d['vectors']:
                for df in v['defs']:
                    if df.get('callback', False):
                        ns = f"{d['name'].lower()}_{v['name'].lower()}_{df['name'].lower()}"
                        parameter_list.append(f'''
  - id: {ns}_variable
    label: '{d["name"]}:{v["name"]}:{df["name"]}'
    category: 'Callbacks'
    dtype: _multiline
    default: ''
    hide: part
'''[1:])
                        callback_regs.append(f'''
    def _{ns}_callback(value):
        ${{{ns}_variable.replace('\\n', '\\n    ') if {ns}_variable.strip() else 'pass'}}

    {self._descr['nodeName'].lower()}.register_{ns}_callback(_{ns}_callback)
'''[1:])

        template_grc_core = f'''
id: nyx_{self._descr["nodeName"].replace("-", "_").lower()}
label: "Nyx {self._descr["nodeName"]}"
category: '[Nyx]/{self._descr["nodeName"]}'
flags: [ python ]

parameters:
  - id: indi_url
    label: INDI URL
    dtype: string
    default: ''

  - id: mqtt_url
    label: MQTT URL
    dtype: string
    default: ''

  - id: nss_url
    label: Stream URL
    dtype: string
    default: ''

  - id: mqtt_username
    label: MQTT Username
    dtype: string
    default: ''
    hide: part

  - id: mqtt_password
    label: MQTT Password
    dtype: string
    default: ''
    hide: part

{''.join(parameter_list)}

templates:
  imports: |
    import atexit
    import {self._descr["nodeName"]}

  make: |
    None
    atexit.register(lambda: {self._descr["nodeName"]}.stop())
    {self._descr["nodeName"]}.start(${{indi_url}}, ${{mqtt_url}}, ${{nss_url}}, ${{mqtt_username}}, ${{mqtt_password}})

{''.join(callback_regs)}

file_format: 1
'''.lstrip()

        filename = os.path.join(self._driver_path, 'grc', f'nyx_{self._descr["nodeName"].lower()}.block.yml')

        with open(filename, 'wt', encoding = 'utf-8') as f:

            f.write(template_grc_core)

        template_grc_sink = f'''
id: nyx_{self._descr["nodeName"].replace("-", "_").lower()}_sink
label: "Nyx {self._descr["nodeName"]} sink"
category: '[Nyx]/{self._descr["nodeName"]}'
flags: [ python ]

templates:
  imports: from gnuradio import nyx_{self._descr["nodeName"].lower()}
  make: nyx_{self._descr["nodeName"].lower()}.nyx_sink(${{device_name}}, ${{stream_name}}, ${{samp_rate}}, ${{frequency}}, ${{fft_size}})

parameters:

- id: device_name
  label: Device name
  dtype: string
  default: ''

- id: stream_name
  label: Stream name
  dtype: string
  default: 'spectrum'

- id: samp_rate
  label: Sample Rate
  dtype: float
  default: samp_rate

- id: frequency
  label: Frequency
  dtype: float
  default: 100e6

- id: fft_size
  label: FFT Size
  dtype: int
  default: 8192

inputs:
- label: in
  domain: stream
  dtype: float
  vlen: ${{fft_size}}

file_format: 1
'''.lstrip()

        filename = os.path.join(self._driver_path, 'grc', f'nyx_{self._descr["nodeName"].lower()}_sink.block.yml')

        with open(filename, 'wt', encoding = 'utf-8') as f:

            f.write(template_grc_sink)

########################################################################################################################
