# -*- coding: utf-8 -*-
########################################################################################################################

import os

########################################################################################################################

from ..abstract_generator import AbstractGenerator, generator_config

########################################################################################################################

@generator_config(name = 'posix-c', null = 'NULL', src_ext = 'c', head_ext = 'h')
class PosixCGenerator(AbstractGenerator):

    ####################################################################################################################

    # noinspection PyUnresolvedReferences
    def __init__(self, args, descr):

        super().__init__(args, descr)

    ####################################################################################################################

    def generate(self) -> None:

        self._generate_cmake()
        self._generate_header()
        self._generate_main()
        self._generate_glue()
        self._generate_devices()

    ####################################################################################################################

    def _generate_cmake(self) -> None:

        ################################################################################################################

        template = '''
########################################################################################################################

cmake_minimum_required(VERSION 3.5)

########################################################################################################################

project({{ descr.nodeName|lower }} C)

set(CMAKE_C_STANDARD 99)

add_compile_options(-Wall -Wno-unknown-pragmas -Wno-unused-function -O3)

########################################################################################################################

find_package(NyxNode REQUIRED)

########################################################################################################################

set(SOURCE_FILES
    {{ cmake_files|join('\\n    ') }}
    ./src/autogen/glue.{{ src_ext }}
    ./src/main.{{ src_ext }}
)

########################################################################################################################

add_executable({{ descr.nodeName|lower }} ${SOURCE_FILES})

target_include_directories({{ descr.nodeName|lower }} PRIVATE ${NYXNODE_INCLUDE_DIR})

target_link_libraries({{ descr.nodeName|lower }} PRIVATE NyxNode::nyx-node-{{ 'static' if descr.static else 'shared' }})

########################################################################################################################
'''[1:]

        filename = os.path.join(self._driver_path, 'CMakeLists.txt')

        if self._override_cmake or not os.path.isfile(filename):

            with open(filename, 'wt', encoding = 'utf-8') as f:

                f.write(self.render(
                    template,
                    cmake_files = [os.path.join('.', 'src', f'device_{device["name"].lower()}.{self._src_ext}') for device in self._devices]
                ))

    ####################################################################################################################

    def _generate_header(self) -> None:

        template = '''
/* !!! AUTOGENERATED FILE !!! */
/*--------------------------------------------------------------------------------------------------------------------*/

#ifndef INDI_NODE_{{ descr.nodeName|upper }}_H
#define INDI_NODE_{{ descr.nodeName|upper }}_H

/*--------------------------------------------------------------------------------------------------------------------*/

#include <unistd.h>

#include <nyx_node.h>

/*--------------------------------------------------------------------------------------------------------------------*/
{%  for d in devices -%}
{%-   for v in d.vectors -%}
{%-     for df in v.defs %}
extern nyx_dict_t *vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }};
{%-     endfor %}
extern nyx_dict_t *vector_{{ d.name|lower }}_{{ v.name|lower }};
{%    endfor -%}
{%- endfor %}
/*--------------------------------------------------------------------------------------------------------------------*/
{%  for d in devices %}
void device_{{ d.name|lower }}_initialize(nyx_node_t *node);
{%- endfor %}
{%  for d in devices %}
void device_{{ d.name|lower }}_finalize(nyx_node_t *node);
{%- endfor %}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_glue_initialize();

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_device_initialize(nyx_node_t *node);

void nyx_device_finalize(nyx_node_t *node);

/*--------------------------------------------------------------------------------------------------------------------*/

#endif /* INDI_NODE_{{ descr.nodeName|upper }}_H */

/*--------------------------------------------------------------------------------------------------------------------*/
'''[1:]

        filename = os.path.join(self._driver_path, 'src', 'autogen', f'glue.{self._head_ext}')

        with open(filename, 'wt', encoding = 'utf-8') as f:

            f.write(self.render(
                template,
                devices = self._devices
            ))

    ####################################################################################################################

    def _generate_main(self) -> None:

        ################################################################################################################
        # credentials.h                                                                                                #
        ################################################################################################################

        template = '''
#define MQTT_USERNAME {% if descr.enableMQTT %}"{{ descr.mqttUsername }}"{% else %}{{ null }}{% endif %}
#define MQTT_PASSWORD {% if descr.enableMQTT %}"{{ descr.mqttPassword }}"{% else %}{{ null }}{% endif %}
#define REDIS_USERNAME {% if descr.enableRedis %}"{{ descr.redisUsername }}"{% else %}{{ null }}{% endif %}
#define REDIS_PASSWORD {% if descr.enableRedis %}"{{ descr.redisPassword }}"{% else %}{{ null }}{% endif %}
'''[1:]

        filename = os.path.join(self._driver_path, 'src', f'credentials.{self._head_ext}')

        with open(filename, 'wt', encoding = 'utf-8') as f:

            f.write(self.render(
                template
            ))

        ################################################################################################################
        # main.c                                                                                                       #
        ################################################################################################################

        template = '''
/*--------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

#include "autogen/glue.{{ head_ext }}"
#include "credentials.{{ head_ext }}"

/*--------------------------------------------------------------------------------------------------------------------*/

static volatile sig_atomic_t s_signo = 0;

static void signal_handler(int signo)
{
    s_signo = signo;
}

/*--------------------------------------------------------------------------------------------------------------------*/

static void print_usage(
    STR_t prog,
    STR_t indi_url,
    STR_t mqtt_url,
    STR_t redis_url,
    STR_t mqtt_username,
    STR_t mqtt_password,
    STR_t redis_username,
    STR_t redis_password,
    int node_timeout
) {
    fprintf(
        stderr,
        "Usage: %s [options]\\n"
        "\\n"
        "Options:\\n"
        "  -i URI   INDI server URL (default: %s)\\n"
        "  -m URI   MQTT broker URL (default: %s)\\n"
        "  -r URI   Redis server URL (default: %s)\\n"
        "  -u USER  MQTT username (default: %s)\\n"
        "  -p PASS  MQTT password (default: %s)\\n"
        "  -U USER  Redis username (default: %s)\\n"
        "  -P PASS  Redis password (default: %s)\\n"
        "  -t MS    Node poll timeout (default: %d)\\n"
        "  -h       Show this help and exit\\n",
        prog,
        indi_url != NULL && indi_url[0] != '\\0' ? indi_url : "none",
        mqtt_url != NULL && mqtt_url[0] != '\\0' ? mqtt_url : "none",
        redis_url != NULL && redis_url[0] != '\\0' ? redis_url : "none",
        mqtt_username != NULL && mqtt_username[0] != '\\0' ? mqtt_username : "none",
        mqtt_password != NULL && mqtt_password[0] != '\\0' ? mqtt_password : "none",
        redis_username != NULL && redis_username[0] != '\\0' ? redis_username : "none",
        redis_password != NULL && redis_password[0] != '\\0' ? redis_password : "none",
        node_timeout
    );
}

/*--------------------------------------------------------------------------------------------------------------------*/

int main(int argc, char **argv)
{
    /*----------------------------------------------------------------------------------------------------------------*/

    STR_t indi_url = {% if descr.enableTCP %}"{{ descr.tcpURI }}"{% else %}{{ null }}{% endif %};
    STR_t mqtt_url = {% if descr.enableMQTT %}"{{ descr.mqttURI }}"{% else %}{{ null }}{% endif %};
    STR_t redis_url = {% if descr.enableRedis %}"{{ descr.redisURI }}"{% else %}{{ null }}{% endif %};

    STR_t mqtt_username = MQTT_USERNAME;
    STR_t mqtt_password = MQTT_PASSWORD;
    STR_t redis_username = REDIS_USERNAME;
    STR_t redis_password = REDIS_PASSWORD;

    int node_timeout = {{ descr.nodeTimeout }};

    /*----------------------------------------------------------------------------------------------------------------*/

    int opt;

    while((opt = getopt(argc, argv, "i:m:r:u:p:U:P:t:h")) != -1)
    {
        switch (opt)
        {
            case 'i':
                indi_url = optarg;
                break;
            case 'm':
                mqtt_url = optarg;
                break;
            case 'r':
                redis_url = optarg;
                break;
            case 'u':
                mqtt_username = optarg;
                break;
            case 'p':
                mqtt_password = optarg;
                break;
            case 'U':
                redis_username = optarg;
                break;
            case 'P':
                redis_password = optarg;
                break;
            case 't':
                node_timeout = atoi(optarg);
                break;
            case 'h':
            default:
                print_usage(
                    argv[0],
                    indi_url,
                    mqtt_url,
                    redis_url,
                    mqtt_username,
                    mqtt_password,
                    redis_username,
                    redis_password,
                    node_timeout
                );

                return (opt == 'h') ? 0 : 1;
        }
    }
    
    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_set_log_level(NYX_LOG_LEVEL_INFO);

    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_memory_initialize();

    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_glue_initialize();

    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_dict_t *vector_list[] = {
{%- for d in devices -%}
{%-   for v in d.vectors %}
        vector_{{ d.name|lower }}_{{ v.name|lower }},
{%-   endfor -%}
{%- endfor %}
        {{ null }},
    };

    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_node_t *node = nyx_node_initialize(
        "{{ descr.nodeName }}",
        vector_list,
        indi_url,
        mqtt_url,
        mqtt_username,
        mqtt_password,
        {{ null }},
        redis_url,
        redis_username,
        redis_password,
        3000,
        true
    );

    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    nyx_device_initialize(node);
    while(s_signo == 0) nyx_node_poll(node, node_timeout);
    nyx_device_finalize(node);

    nyx_node_finalize(node, true);
    
    /*----------------------------------------------------------------------------------------------------------------*/

    nyx_memory_finalize();

    /*----------------------------------------------------------------------------------------------------------------*/

    printf("Bye.\\n");

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------*/
'''[1:]

        filename = os.path.join(self._driver_path, 'src', f'main.{self._src_ext}')

        if self._override_main or not os.path.isfile(filename):

            with open(filename, 'wt', encoding = 'utf-8') as f:

                f.write(self.render(
                    template,
                    devices = self._devices
                ))

    ####################################################################################################################

    def _generate_glue(self) -> None:

        ################################################################################################################

        template = '''
/* !!! AUTOGENERATED FILE !!! */
/*--------------------------------------------------------------------------------------------------------------------*/

#include "glue.{{ head_ext }}"

/*--------------------------------------------------------------------------------------------------------------------*/
{%  for d in devices -%}
{%-   for v in d.vectors -%}
{%-     for df in v.defs %}
nyx_dict_t *vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = {{ null }};
{%-     endfor %}
nyx_dict_t *vector_{{ d.name|lower }}_{{ v.name|lower }} = {{ null }};
{%    endfor -%}
{%- endfor %}
/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_glue_initialize()
{
    /*----------------------------------------------------------------------------------------------------------------*/
    /* INITIALIZE VECTORS                                                                                             */
    /*----------------------------------------------------------------------------------------------------------------*/

{%- for d in devices -%}
{%-   for v in d.vectors %}

    /* VECTOR {{ d.name|upper }}::{{ v.name|upper }} */
{%      for df in v.defs -%}
{%-       if v.type == 'number' -%}
{%          set subtype = get_number_type(df.format) -%}
{%-         if subtype == NYX_NUMBER_INT %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_number_prop_new_int("{{ df.name }}", "{{ df.label }}", "{{ df.format }}", {{ df.min }}, {{ df.max }}, {{ df.step }}, {{ df.value }});
{%-         elif subtype == NYX_NUMBER_UINT %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_number_prop_new_uint("{{ df.name }}", "{{ df.label }}", "{{ df.format }}", {{ df.min }}, {{ df.max }}, {{ df.step }}, {{ df.value }});
{%-         elif subtype == NYX_NUMBER_LONG %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_number_prop_new_long("{{ df.name }}", "{{ df.label }}", "{{ df.format }}", {{ df.min }}, {{ df.max }}, {{ df.step }}, {{ df.value }});
{%-         elif subtype == NYX_NUMBER_ULONG %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_number_prop_new_ulong("{{ df.name }}", "{{ df.label }}", "{{ df.format }}", {{ df.min }}, {{ df.max }}, {{ df.step }}, {{ df.value }});
{%-         elif subtype == NYX_NUMBER_DOUBLE %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_number_prop_new_double("{{ df.name }}", "{{ df.label }}", "{{ df.format }}", {{ df.min }}, {{ df.max }}, {{ df.step }}, {{ df.value }});
{%-         endif -%}
{%-       elif v.type == 'text' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_text_prop_new("{{ df.name }}", "{{ df.label }}", "{{ df.value }}");
{%-       elif v.type == 'light' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_light_prop_new("{{ df.name }}", "{{ df.label }}", {{ df.value }});
{%-       elif v.type == 'switch' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_switch_prop_new("{{ df.name }}", "{{ df.label }}", {{ df.value }});
{%-       elif v.type == 'blob' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_blob_prop_new("{{ df.name }}", "{{ df.label }}", "{{ df.format }}", {{ df.value }});
{%-       elif v.type == 'stream' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }} = nyx_stream_prop_new("{{ df.name }}", "{{ df.label }}");
{%-       endif -%}
{%-     endfor %}

    nyx_dict_t *{{ d.name|lower }}_{{ v.name|lower }}_props[] = {
{%-     for df in v.defs %}
        vector_{{ d.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }},
{%-     endfor %}
        {{ null }},
    };

    nyx_opts_t {{ d.name|lower }}_{{ v.name|lower }}_opts = {
        .group = {% if (v.group|default('')|trim)|length > 0 %}"{{ v.group|trim }}"{% else %}{{ null }}{% endif %},
        .label = {% if (v.label|default('')|trim)|length > 0 %}"{{ v.label|trim }}"{% else %}{{ null }}{% endif %},
        .hints = {% if (v.hints|default('')|trim)|length > 0 %}"{{ v.hints|trim }}"{% else %}{{ null }}{% endif %},
        .message = {% if (v.message|default('')|trim)|length > 0 %}"{{ v.message|trim }}"{% else %}{{ null }}{% endif %},
        .timeout = {% if v.timeout|default(None) is not none %}{{ v.timeout }}{% else %}0{% endif %},
    };
{%      if v.type == 'number' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }} = nyx_number_vector_new(
        "{{ d.name }}",
        "{{ v.name }}",
        {{ v.state }},
        {{ v.perm }},
        {{ d.name|lower }}_{{ v.name|lower }}_props,
        &{{ d.name|lower }}_{{ v.name|lower }}_opts
    );
{%-     elif v.type == 'text' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }} = nyx_text_vector_new(
        "{{ d.name }}",
        "{{ v.name }}",
        {{ v.state }},
        {{ v.perm }},
        {{ d.name|lower }}_{{ v.name|lower }}_props,
        &{{ d.name|lower }}_{{ v.name|lower }}_opts
    );
{%-     elif v.type == 'light' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }} = nyx_light_vector_new(
        "{{ d.name }}",
        "{{ v.name }}",
        {{ v.state }},
        {{ d.name|lower }}_{{ v.name|lower }}_props,
        &{{ d.name|lower }}_{{ v.name|lower }}_opts
    );
{%-     elif v.type == 'switch' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }} = nyx_switch_vector_new(
        "{{ d.name }}",
        "{{ v.name }}",
        {{ v.state }},
        {{ v.perm }},
        {{ v.rule }},
        {{ d.name|lower }}_{{ v.name|lower }}_props,
        &{{ d.name|lower }}_{{ v.name|lower }}_opts
    );
{%-     elif v.type == 'blob' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }} = nyx_blob_vector_new(
        "{{ d.name }}",
        "{{ v.name }}",
        {{ v.state }},
        {{ v.perm }},
        {{ d.name|lower }}_{{ v.name|lower }}_props,
        &{{ d.name|lower }}_{{ v.name|lower }}_opts
    );
{%-     elif v.type == 'stream' %}
    vector_{{ d.name|lower }}_{{ v.name|lower }} = nyx_stream_vector_new(
        "{{ d.name }}",
        "{{ v.name }}",
        {{ v.state }},
        {{ d.name|lower }}_{{ v.name|lower }}_props,
        &{{ d.name|lower }}_{{ v.name|lower }}_opts
    );
{%-     endif -%}
{%-     if d.disabled|default(false) or v.disabled|default(false) %}

    vector_{{ d.name|lower }}_{{ v.name|lower }}->base.flags |= NYX_FLAGS_DISABLED;
{%-     endif %}
{%-   endfor -%}
{%- endfor %}

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_device_initialize(nyx_node_t *node)
{
    /*----------------------------------------------------------------------------------------------------------------*/
    /* INITIALIZE HARDWARE                                                                                            */
    /*----------------------------------------------------------------------------------------------------------------*/
{%  for d in devices %}
    device_{{ d.name|lower }}_initialize(node);
{%- endfor %}

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/

void nyx_device_finalize(nyx_node_t *node)
{
    /*----------------------------------------------------------------------------------------------------------------*/
    /* FINALIZE HARDWARE                                                                                              */
    /*----------------------------------------------------------------------------------------------------------------*/
{%  for d in devices %}
    device_{{ d.name|lower }}_finalize(node);
{%- endfor %}

    /*----------------------------------------------------------------------------------------------------------------*/
}

/*--------------------------------------------------------------------------------------------------------------------*/
'''[1:]

        filename = os.path.join(self._driver_path, 'src', 'autogen', f'glue.{self._src_ext}')

        with open(filename, 'wt', encoding = 'utf-8') as f:

            f.write(self.render(
                template,
                devices = self._devices
            ))

    ####################################################################################################################

    def _generate_devices(self) -> None:

        ################################################################################################################

        template = '''
/*--------------------------------------------------------------------------------------------------------------------*/

#include "autogen/glue.{{ head_ext }}"

/*--------------------------------------------------------------------------------------------------------------------*/

{%- set ns = namespace(any_callbacks = false) -%}

{%- for v in device.vectors -%}
{%-   for df in v.defs if df.callback -%}
{#-     ------------------------------------------------------------------------------------------------------------ -#}
{%-     set ns.any_callbacks = true -%}
{#-     ------------------------------------------------------------------------------------------------------------- #}
{%      if v.type == 'number' -%}
{%          set subtype = get_number_type(df.format) -%}
{%-         if subtype == NYX_NUMBER_INT %}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def, int new_value, int old_value)
{%-         elif subtype == NYX_NUMBER_UINT %}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def, unsigned int new_value, unsigned int old_value)
{%-         elif subtype == NYX_NUMBER_LONG %}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def, long new_value, long old_value)
{%-         elif subtype == NYX_NUMBER_ULONG %}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def, unsigned long new_value, unsigned long old_value)
{%-         elif subtype == NYX_NUMBER_DOUBLE %}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def, double new_value, double old_value)
{%-         endif -%}
{%-     elif v.type == 'text' %}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def, STR_t new_value, STR_t old_value)
{%-     elif v.type == 'light' %}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def, int new_value, int old_value)
{%-     elif v.type == 'switch' %}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def, int new_value, int old_value)
{%-     elif v.type == 'switch' %}
static bool _{{ v.name|lower }}_{{ df.name|lower }}_callback(nyx_dict_t *vector, nyx_dict_t *def, size_t size, BUFF_t buff)
{%-     endif %}
{
    /* TO BE IMPLEMENTED */

    return true;
}

/*--------------------------------------------------------------------------------------------------------------------*/

{%-   endfor -%}

{%-   if v.callback and v.type != 'stream' -%}
{#-     ------------------------------------------------------------------------------------------------------------ -#}
{%-     set ns.any_callbacks = true -%}
{#-     ------------------------------------------------------------------------------------------------------------- #}

static void _{{ v.name|lower }}_callback(nyx_dict_t *vector, bool modified)
{
    /* TO BE IMPLEMENTED */
}
{%-   endif -%}
{%- endfor -%}

{%- if not ns.any_callbacks %}

/* TO BE IMPLEMENTED */
{%- endif %}

/*--------------------------------------------------------------------------------------------------------------------*/

void device_{{ device.name|lower }}_initialize(nyx_node_t *node)
{
{%- for v in device.vectors -%}
{%-   for df in v.defs if df.callback %}
{%-     if v.type == 'number' -%}
{%          set subtype = get_number_type(df.format) -%}
{%-         if subtype == NYX_NUMBER_INT %}
    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._int = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         elif subtype == NYX_NUMBER_UINT %}
    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._uint = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         elif subtype == NYX_NUMBER_LONG %}
    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._long = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         elif subtype == NYX_NUMBER_ULONG %}
    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._ulong = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         elif subtype == NYX_NUMBER_DOUBLE %}
    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._double = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-         endif -%}
{%-     elif v.type == 'text' %}
    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._str = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-     elif v.type == 'light' %}
    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._int = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-     elif v.type == 'switch' %}
    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._int = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-     elif v.type == 'blob' %}
    vector_{{ device.name|lower }}_{{ v.name|lower }}_{{ df.name|lower }}->base.in_callback._blob = _{{ v.name|lower }}_{{ df.name|lower }}_callback;
{%-     endif -%}
{%-   endfor -%}
{%-   if v.callback and v.type != 'stream' %}

    vector_{{ device.name|lower }}_{{ v.name|lower }}->base.in_callback._vector = _{{ v.name|lower }}_callback;
{%    endif -%}
{%- endfor %}
    /* TO BE IMPLEMENTED */
}

/*--------------------------------------------------------------------------------------------------------------------*/

void device_{{ device.name|lower }}_finalize(nyx_node_t *node)
{
    /* TO BE IMPLEMENTED */
}

/*--------------------------------------------------------------------------------------------------------------------*/
'''[1:]

        for device in self._devices:

            filename = os.path.join(self._driver_path, 'src', f'device_{device["name"].lower()}.{self._src_ext}')

            if self._override_device or not os.path.isfile(filename):

                with open(filename, 'wt', encoding = 'utf-8') as f:

                    f.write(self.render(
                        template,
                        device = device
                    ))

########################################################################################################################
